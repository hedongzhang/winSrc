/*
 * init.cpp
 *
 *  Created on: 2014年12月14日
 *      Author: HDZhang
 */

#include"init.h"
#include<fstream>
#include<memory.h>

using namespace n_init;
using namespace std;

/*启动初始化
 * 读取配置文件，根据配置文件读入关键变量值并载入关键字映射和模板
 * @字符------模板类型
 * 一般字符----模板路径
 * #字符------注释
 */
int Init::startInit()
{
	cout<<"=====开始初始化====="<<endl;

	//读取配置信息
	if(readConfig()==RETURN_FAILED)
	{
		cout<<"=====读取配置信息失败====="<<endl;
		return RETURN_FAILED;
	}

	//初始化相关值
	InitOtherValue();

	cout<<"=====初始化完成====="<<endl;
	return RETURN_SUCCESS;
}

//读取配置信息
int Init::readConfig()
{
	cout<<"=====读取配置====="<<endl;
	ifstream ifstre;
	ifstre.open(CONFIG_FILE_FULLNAME.c_str());
	if(ifstre.is_open())
	{
		string currentTemplateName("");
		string currentTemplateValue("");

		while(!ifstre.eof())
		{
			char fileContextChar[200];
			memset(fileContextChar,0,sizeof(fileContextChar));
			ifstre.getline(fileContextChar,2000);
			if(fileContextChar[0]=='@')
			{
				string templateName(fileContextChar);

				if(templateName.compare("@KeyTemplate")==0 || templateName.compare("@CodeTemplate")==0)
				{
					if(!currentTemplateName.empty())
					{
						int returnCode=RETURN_SUCCESS;
						if(currentTemplateName.compare("@KeyTemplate")==0)
						{
							//读取路径下的关键字映射文件
							returnCode=readKeyTemplate(currentTemplateValue);
						}
						else if(currentTemplateName.compare("@CodeTemplate")==0)
						{
							//读取路径下的代码模板并与模板文件名映射
							returnCode=readCodeTemplate(currentTemplateValue);
						}
						else
						{
							m_baseMessage.insert(map<string,string>::value_type(currentTemplateName,currentTemplateValue));
						}
						if(returnCode==RETURN_FAILED)
						{
							cout<<"=====读取关键字映射文件或代码模板配置文件出错！===="<<endl;
							ifstre.close();
							return RETURN_FAILED;
						}
					}
				}
				else if(currentTemplateName!=templateName)
				{
					if(!currentTemplateName.empty())
					{
						int returnCode=RETURN_SUCCESS;
						if(currentTemplateName.compare("@KeyTemplate")==0)
						{
							//读取路径下的关键字映射文件
							returnCode=readKeyTemplate(currentTemplateValue);
						}
						else if(currentTemplateName.compare("@CodeTemplate")==0)
						{
							//读取路径下的代码模板并与模板文件名映射
							returnCode=readCodeTemplate(currentTemplateValue);
						}
						else
						{
							m_baseMessage.insert(map<string,string>::value_type(currentTemplateName,currentTemplateValue));
						}
						if(returnCode==RETURN_FAILED)
						{
							cout<<"=====读取关键字映射文件或代码模板配置文件出错！====="<<endl;
							ifstre.close();
							return RETURN_FAILED;
						}
					}
				}
				currentTemplateName=templateName;
				currentTemplateValue="";
				//读到结束符退出
				if(currentTemplateName.compare("@")==0)
				{
					break;
				}
				continue;
			}
			else if(fileContextChar[0]=='#')
			{
				//注释
				continue;
			}
			else
			{
				currentTemplateValue+=string(fileContextChar);
			}
		}

		//cout<<fileContext;
		ifstre.close();
	}
	else
	{
		cout<<"=====打开配置文件异常====="<<endl;
		ifstre.close();
		return RETURN_FAILED;
	}
	showInitMessage();


	cout<<"=====配置读取结束====="<<endl;
	return RETURN_SUCCESS;
}

//初始化相关值
int Init::InitOtherValue() {
	//生成相关值
	cout << "=====生成相关值=====" << endl;

	string keyTemp1="@CLASS_NAME";
	string keyTemp2="@SERVICE_NAME";
	string serviceName = "";
	if(getBaseMessage(keyTemp1, serviceName)==RETURN_FAILED)
	{
		if (getBaseMessage(keyTemp2, serviceName)==RETURN_SUCCESS)
		{
			toupper(serviceName[0]);
			string::size_type pos = 1;
			while (pos < serviceName.length())
			{
				if (serviceName[pos] == '_') {
					serviceName.erase(pos, 1);
					serviceName[pos] = toupper(serviceName[pos]);
				} else {
					serviceName[pos] = tolower(serviceName[pos]);
				}
				pos++;
			}
			string className = "DCCrm";
			className += serviceName;
			cout << "生成类名：" + className << endl;

			setBaseMessage(keyTemp1,className);
		}
		else
		{
			cout << "未配置类名，同时服务名获取失败，无法生成类名"<< endl;
			return RETURN_FAILED;
		}
	}

	keyTemp1="@DATE";
	if(getBaseMessage(keyTemp1, serviceName)==RETURN_FAILED)
	{

	}

	cout << "=====生成相关值完成=====" << endl;
	return RETURN_SUCCESS;
}

//根据路径读取关键字模板配置
int Init::readKeyTemplate(string path)
{
    string keyTemplateName=path.substr(path.find_last_of('/')+1);
    if(!keyTemplateName.empty())
    {
        ifstream ifstre;
        ifstre.open(path.c_str());
        if(ifstre.is_open())
        {
            map<string,string> keyTemplate;
            string keyContext;
            string templateContext;
            while(!ifstre.eof())
            {
                ifstre>>keyContext>>templateContext;
                if(keyContext.empty()||templateContext.empty())
                {
                    return RETURN_FAILED;
                }
                keyTemplate.insert(pair<string,string>(keyContext,templateContext));
            }
            ifstre.close();
            return Base::setKeyMap(keyTemplateName,keyTemplate);
        }
        return RETURN_FAILED;
    }
    return RETURN_SUCCESS;
}
//根据路径读取代码模板配置
int Init::readCodeTemplate(string path)
{
    string keyTemplateName=path.substr(path.find_last_of('/')+1);
    if(!keyTemplateName.empty())
    {
        return Base::setCodeTemplateMap(keyTemplateName,path);
    }
    return RETURN_SUCCESS;
}

//输出读取的配置信息
void Init::showInitMessage() {
	cout << "=====读取值列表=====" << endl;
	for (map<string, string>::iterator ite = m_baseMessage.begin();
			ite != m_baseMessage.end(); ite++) {
		cout << ite->first << ":" << ite->second << endl;
	}
	cout << "=====读取模板列表=====" << endl;
	Base::showBaseMessage();
}



